<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="A local-first recipe management app">
<meta name="theme-color" content="#2c3e50">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icons/icon-192.png" type="image/png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>Recipe Box</title>
<style>
  body {
    font: 16px/1.5 system-ui, sans-serif;
    margin: 0;
    padding: 0 2rem;
  }
  header {
    margin: 2rem 0 1rem;
  }
  ul {
    list-style: none;
    padding-left: 0;
  }
  li {
    margin: .25rem 0;
  }
  a {
    text-decoration: none;
    color: #0366d6;
  }
  a:hover {
    text-decoration: underline;
  }
  h1 {
    margin: 0 0 1rem;
    font-size: 1.8rem;
  }
  img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1rem 0;
  }
  .pick {
    margin: 1.5rem 0;
  }
  .hidden {
    display: none;
  }
  .install-banner {
    background: #2c3e50;
    color: white;
    padding: 1rem 2rem;
    margin: 0 -2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }
  .install-banner button {
    background: white;
    color: #2c3e50;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
  .install-banner button:hover {
    opacity: 0.9;
  }
  .debug-info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    font-size: 12px;
    border-radius: 4px;
    max-width: 300px;
    z-index: 1000;
  }
  .sync-panel {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
  }
  .sync-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .sync-status.connected {
    color: #28a745;
  }
  .sync-status.disconnected {
    color: #dc3545;
  }
  .sync-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .sync-buttons button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    background: #007bff;
    color: white;
    cursor: pointer;
    font-size: 14px;
  }
  .sync-buttons button:hover {
    background: #0056b3;
  }
  .sync-buttons button:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }
  .sync-progress {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: #e9ecef;
    border-radius: 4px;
    font-size: 14px;
  }
</style>
</head>
<body>
<div id="install-banner" class="install-banner hidden">
  <span>Install Recipe Box for easy access</span>
  <button id="install-btn">Install</button>
</div>
<header>
  <div class="sync-panel">
    <div class="sync-status disconnected" id="sync-status">
      <span id="sync-status-text">Not connected to cloud storage</span>
    </div>
    <div class="sync-buttons">
      <button id="sync-connect-btn">Connect to Google Drive</button>
      <button id="sync-now-btn" disabled>Sync Now</button>
      <button id="sync-disconnect-btn" disabled>Disconnect</button>
    </div>
    <div class="sync-progress hidden" id="sync-progress">
      <div id="sync-progress-text">Ready to sync</div>
    </div>
  </div>
  
  <button class="pick" id="pickDir">Open recipe folder (fallback)</button>
  <ul id="index"></ul>
</header>

<article id="viewer"></article>

<div id="debug-info" class="debug-info" style="display: none;"></div>

<script type="module">
  import matter from 'https://cdn.jsdelivr.net/npm/gray-matter@4/+esm';
  import markdownIt from 'https://cdn.jsdelivr.net/npm/markdown-it@14/+esm';
  import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3/+esm';
  import { get, set, clear } from 'https://cdn.jsdelivr.net/npm/idb-keyval@6/+esm';
  
  // Import cloud sync modules
  import './cloud-storage-interface.js';
  import './google-drive-provider.js';
  import { SyncManager } from './sync-manager.js';

  /* Init markdown-it  */
  const md = markdownIt({
    html: true,
    linkify: true,
    typographer: true
  });

  // Global state
  let dirHandle = null;
  const slugToFile = new Map();
  
  // Sync manager
  const syncManager = new SyncManager();
  let syncEnabled = false;
  
  // Expose sync manager for debugging
  window.debugSync = {
    manager: syncManager,
    async listCloudRecipes() {
      if (!syncManager.provider) {
        console.log('Sync not initialized');
        return [];
      }
      const recipes = await syncManager.provider.listRecipes();
      console.log('Cloud recipes found:', recipes);
      return recipes;
    },
    async listLocalRecipes() {
      const recipes = await get('recipeData') || [];
      console.log('Local recipes found:', recipes);
      return recipes;
    },
    async testSync() {
      console.log('Testing sync process...');
      await this.listLocalRecipes();
      await this.listCloudRecipes();
    }
  };

  // UI references
  const pickBtn = document.getElementById('pickDir');
  const indexUl = document.getElementById('index');
  const viewer = document.getElementById('viewer');
  
  // Sync UI references
  const syncStatus = document.getElementById('sync-status');
  const syncStatusText = document.getElementById('sync-status-text');
  const syncConnectBtn = document.getElementById('sync-connect-btn');
  const syncNowBtn = document.getElementById('sync-now-btn');
  const syncDisconnectBtn = document.getElementById('sync-disconnect-btn');
  const syncProgress = document.getElementById('sync-progress');
  const syncProgressText = document.getElementById('sync-progress-text');

  // Helper functions
  const slugify = (s) =>
    s.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');

  const renderIndex = async () => {
    indexUl.innerHTML = '';
    slugToFile.clear();
    
    // First priority: Try to load from synced recipes (IndexedDB)
    const syncedRecipes = await get('recipeData') || [];
    if (syncedRecipes.length > 0) {
      console.log(`Loading ${syncedRecipes.length} synced recipes`);
      for (const recipe of syncedRecipes) {
        const slug = slugify(recipe.name.replace(/\.md$/, ''));
        // Create a File-like object from synced data
        const file = new File([recipe.content], recipe.name, {
          type: 'text/markdown',
          lastModified: recipe.lastModified
        });
        slugToFile.set(slug, file);
        const li = document.createElement('li');
        li.innerHTML = `<a href="#recipe=${slug}">${recipe.name.replace(/\.md$/, '')}</a> <span style="color: #28a745;">‚òÅÔ∏è</span>`;
        indexUl.appendChild(li);
      }
      return; // Exit early if we have synced recipes
    }
    
    // Fallback: Handle local directory/file selection
    if (!dirHandle) {
      const li = document.createElement('li');
      li.innerHTML = '<em>No recipes loaded. Connect to Google Drive above or use the fallback folder picker.</em>';
      indexUl.appendChild(li);
      return;
    }
    
    if (Array.isArray(dirHandle)) {
      // Fallback mode: array of files
      for (const file of dirHandle) {
        if (file.name.endsWith('.md')) {
          const slug = slugify(file.name.replace(/\.md$/, ''));
          slugToFile.set(slug, file);
          const li = document.createElement('li');
          li.innerHTML = `<a href="#recipe=${slug}">${file.name.replace(/\.md$/, '')}</a> <span style="color: #6c757d;">üìÅ</span>`;
          indexUl.appendChild(li);
        }
      }
    } else {
      // Modern mode: directory handle
      for await (const entry of dirHandle.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.md')) {
          const slug = slugify(entry.name.replace(/\.md$/, ''));
          slugToFile.set(slug, entry);
          const li = document.createElement('li');
          li.innerHTML = `<a href="#recipe=${slug}">${entry.name.replace(/\.md$/, '')}</a> <span style="color: #6c757d;">üìÅ</span>`;
          indexUl.appendChild(li);
        }
      }
    }
  };

  const renderRecipe = async (slug) => {
    const entry = slugToFile.get(slug);
    if (!entry) {
      viewer.textContent = 'Recipe not found.';
      return;
    }

    const file = entry.getFile ? await entry.getFile() : entry;  // Works for both FileSystemFileHandle and File
    const text = await file.text();
    const { data: fm, content } = matter(text);

    let html = md.render(content);
    html = DOMPurify.sanitize(html);

    // Inject into DOM
    viewer.innerHTML = `
    <h1>${fm.title ?? file.name.replace(/\\.md$/, '')}</h1>
    ${fm.image ? `<img src="${fm.image}" alt="">` : ''}
    ${Array.isArray(fm.ingredients) ? `
      <h2>What you'll need</h2>
      <ul>${fm.ingredients.map(i => `<li>${DOMPurify.sanitize(i)}</li>`).join('')}</ul>` : ''}
    <h2>What to do</h2>
    ${html}
  `;
  };

  async function verifyPermission(handle, mode = 'read') {
    const opts = { mode };
    // Was permission already granted?
    console.log(await handle.queryPermission(opts))
    if ((await handle.queryPermission(opts)) === 'granted') return true;
    // If not, ask (only once per session)
    return (await handle.requestPermission(opts)) === 'granted';
  }


  // Routing: react to hash
  const route = () => {
    const match = location.hash.match(/recipe=([\w-]+)/);
    if (match && dirHandle) renderRecipe(match[1]);
  };
  window.addEventListener('hashchange', route);

  // Sync functions
  async function updateSyncStatus() {
    const status = await syncManager.getStatus();
    const isAuth = await syncManager.isAuthenticated();
    
    if (isAuth && status.connected) {
      syncStatus.className = 'sync-status connected';
      syncStatusText.textContent = `Connected to ${status.provider}`;
      if (status.lastSync) {
        syncStatusText.textContent += ` - Last sync: ${new Date(status.lastSync).toLocaleString()}`;
      }
      syncConnectBtn.disabled = true;
      syncNowBtn.disabled = status.syncInProgress;
      syncDisconnectBtn.disabled = false;
    } else if (syncManager.provider) {
      syncStatus.className = 'sync-status disconnected';
      syncStatusText.textContent = 'Google Drive available - click to connect';
      syncConnectBtn.disabled = false;
      syncNowBtn.disabled = true;
      syncDisconnectBtn.disabled = true;
    } else {
      syncStatus.className = 'sync-status disconnected';
      syncStatusText.textContent = 'Initializing cloud sync...';
      syncConnectBtn.disabled = true;
      syncNowBtn.disabled = true;
      syncDisconnectBtn.disabled = true;
    }
  }

  async function initializeSync() {
    try {
      // Try to load config and initialize sync
      const { CONFIG } = await import('./config.js');
      const success = await syncManager.initProvider('google-drive', { clientId: CONFIG.google.clientId });
      
      if (success) {
        syncEnabled = true;
        console.log('Sync initialized successfully');
      } else {
        console.log('Sync initialization failed');
      }
    } catch (error) {
      console.log('Sync not available:', error.message);
      // Hide sync panel if config is missing
      document.querySelector('.sync-panel').style.display = 'none';
      return;
    }
    
    await updateSyncStatus();
  }

  async function connectToSync() {
    syncConnectBtn.disabled = true;
    syncStatusText.textContent = 'Connecting to Google Drive...';
    
    const result = await syncManager.authenticate();
    if (result.success) {
      await updateSyncStatus();
      // Try to sync immediately after connecting
      await performSync();
    } else {
      syncStatusText.textContent = `Connection failed: ${result.error}`;
      syncConnectBtn.disabled = false;
    }
  }

  async function performSync() {
    if (!await syncManager.isAuthenticated()) {
      await connectToSync();
      return;
    }
    
    syncProgress.classList.remove('hidden');
    syncNowBtn.disabled = true;
    
    const result = await syncManager.sync((progress) => {
      syncProgressText.textContent = `${progress.status}: ${progress.progress}%`;
      if (progress.current) {
        syncProgressText.textContent += ` - ${progress.current}`;
      }
    });
    
    if (result.success) {
      syncProgressText.textContent = `Sync complete! Uploaded: ${result.uploaded}, Downloaded: ${result.downloaded}`;
      // Refresh the recipe list
      await renderIndex();
    } else {
      syncProgressText.textContent = `Sync failed: ${result.error}`;
    }
    
    await updateSyncStatus();
    setTimeout(() => syncProgress.classList.add('hidden'), 3000);
  }

  async function disconnectFromSync() {
    await syncManager.signOut();
    await updateSyncStatus();
  }

  async function pickRecipeFolder() {
    if ('showDirectoryPicker' in window) {
      // Modern Chromium path (read + write)
      return await window.showDirectoryPicker();
    }

    // Fallback: let user pick a whole folder read-only (WebKit proprietary)
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'file';
      input.webkitdirectory = true;
      input.multiple = true;
      input.addEventListener('change', () => {
        resolve(Array.from(input.files));
      });
      input.click();
    });
  }

  // Auto-restore directory permission on reload
  pickBtn.addEventListener('click', async () => {
    dirHandle = await pickRecipeFolder();
    if (dirHandle) {
      // Save both directory handles and file arrays
      if (dirHandle.kind === 'directory') {
        // Modern browsers: save directory handle
        await set('recipeDirHandle', dirHandle);
      } else if (Array.isArray(dirHandle)) {
        // Fallback browsers: Store recipe content in IndexedDB for persistence
        console.log('Storing recipe files in IndexedDB for persistence...');
        const recipes = [];
        for (const file of dirHandle) {
          if (file.name.endsWith('.md')) {
            const content = await file.text();
            recipes.push({
              name: file.name,
              content: content,
              lastModified: file.lastModified,
              size: file.size
            });
          }
        }
        await set('recipeData', recipes);
        console.log(`Stored ${recipes.length} recipes in IndexedDB`);
      }
      await renderIndex();
      indexUl.classList.remove('hidden');
      route();
    }
  });
  
  // Sync event handlers
  syncConnectBtn.addEventListener('click', connectToSync);
  syncNowBtn.addEventListener('click', performSync);
  syncDisconnectBtn.addEventListener('click', disconnectFromSync);
  
  (async () => {
    try {
      // Try to restore directory handle first (modern browsers)
      const saved = await get('recipeDirHandle');
      if (saved && await verifyPermission(saved, 'read')) {
        dirHandle = saved;
        await renderIndex();
        indexUl.classList.remove('hidden');
        route();
        return;
      }
    } catch (err) {
      console.log('Error restoring directory handle:', err);
    }
    
    try {
      // Fallback: try to restore recipe data (Android/fallback browsers)
      const recipeData = await get('recipeData');
      if (recipeData && recipeData.length > 0) {
        console.log(`Restored ${recipeData.length} recipes from IndexedDB`);
        // Create mock File objects from stored data
        dirHandle = recipeData.map(recipe => new File([recipe.content], recipe.name, {
          type: 'text/markdown',
          lastModified: recipe.lastModified
        }));
        await renderIndex();
        indexUl.classList.remove('hidden');
        route();
      }
    } catch (err) {
      console.log('Error restoring recipe data:', err);
    }
  })();

  // Initialize sync functionality
  (async () => {
    await initializeSync();
    // After sync is initialized, try to load synced recipes
    await renderIndex();
    indexUl.classList.remove('hidden');
    route();
  })();

  // PWA Service Worker Registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const registration = await navigator.serviceWorker.register('/forked/sw.js');
        console.log('ServiceWorker registration successful:', registration.scope);
        
        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker available
              console.log('New content available; refresh to update.');
            }
          });
        });
      } catch (err) {
        console.log('ServiceWorker registration failed:', err);
      }
    });
  }

  // PWA Install prompt
  let deferredPrompt;
  const installBanner = document.getElementById('install-banner');
  const installBtn = document.getElementById('install-btn');
  
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    // Only show banner if not already running as installed PWA
    if (!isRunningStandalone()) {
      installBanner.classList.remove('hidden');
    }
  });
  
  // Check if app is running in standalone mode (installed PWA)
  function isRunningStandalone() {
    const standalone = window.matchMedia('(display-mode: standalone)').matches ||
                      window.navigator.standalone === true ||
                      document.referrer.includes('android-app://') ||
                      window.matchMedia('(display-mode: fullscreen)').matches ||
                      window.matchMedia('(display-mode: minimal-ui)').matches;
    
    console.log('PWA Standalone Detection:', {
      'display-mode: standalone': window.matchMedia('(display-mode: standalone)').matches,
      'navigator.standalone': window.navigator.standalone,
      'referrer': document.referrer,
      'display-mode: fullscreen': window.matchMedia('(display-mode: fullscreen)').matches,
      'display-mode: minimal-ui': window.matchMedia('(display-mode: minimal-ui)').matches,
      'final result': standalone
    });
    
    return standalone;
  }
  
  // Hide banner if already running as PWA
  async function checkAndHideBanner() {
    // Check if previously installed
    const wasInstalled = await get('appInstalled');
    const isStandalone = isRunningStandalone();
    
    // Show debug info on screen
    const debugDiv = document.getElementById('debug-info');
    if (debugDiv) {
      debugDiv.innerHTML = `
        <strong>PWA Debug Info:</strong><br>
        Current URL: ${window.location.href}<br>
        Standalone: ${isStandalone}<br>
        Was Installed: ${wasInstalled}<br>
        Display Mode: ${window.matchMedia('(display-mode: standalone)').matches ? 'standalone' : 'browser'}<br>
        Navigator Standalone: ${window.navigator.standalone}<br>
        Referrer: ${document.referrer}<br>
        User Agent: ${navigator.userAgent.substring(0, 50)}...<br>
        <button onclick="clearCacheAndReload()" style="margin-top:5px;padding:2px 5px;">Clear Cache & Reload</button>
      `;
      debugDiv.style.display = 'block';
      
      // Hide debug after 10 seconds
      setTimeout(() => debugDiv.style.display = 'none', 10000);
    } else {
      console.error('Debug div not found!');
    }
    
    if (isStandalone || wasInstalled) {
      console.log('Running as PWA or previously installed - hiding install banner');
      if (installBanner) {
        installBanner.classList.add('hidden');
        installBanner.style.display = 'none'; // Force hide with CSS
        if (debugDiv) debugDiv.innerHTML += `<br><strong>Banner Hidden:</strong> YES`;
      } else {
        if (debugDiv) debugDiv.innerHTML += `<br><strong>ERROR:</strong> Banner element not found!`;
      }
    } else {
      console.log('Running in browser - install banner may be shown');
      if (debugDiv) debugDiv.innerHTML += `<br><strong>Banner:</strong> Should be visible`;
    }
  }
  
  // Only check after DOM is loaded to ensure elements exist
  document.addEventListener('DOMContentLoaded', checkAndHideBanner);
  
  // Also check when page is fully loaded
  window.addEventListener('load', checkAndHideBanner);
  
  installBtn.addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);
    deferredPrompt = null;
    installBanner.classList.add('hidden');
  });
  
  // Hide banner if already installed
  window.addEventListener('appinstalled', async () => {
    console.log('Recipe Box app installed');
    installBanner.classList.add('hidden');
    // Remember that the app was installed
    await set('appInstalled', true);
  });

  // Function to clear cache and reload (for debugging)
  window.clearCacheAndReload = async () => {
    try {
      // Clear service worker caches
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
      
      // Clear IndexedDB data
      await clear();
      
      // Unregister service worker
      if ('serviceWorker' in navigator) {
        const registrations = await navigator.serviceWorker.getRegistrations();
        await Promise.all(registrations.map(reg => reg.unregister()));
      }
      
      // Force reload
      window.location.reload(true);
    } catch (err) {
      console.error('Error clearing cache:', err);
      window.location.reload(true);
    }
  };
</script>
</body>
</html>
