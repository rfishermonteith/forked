<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="A local-first recipe management app">
<meta name="theme-color" content="#2c3e50">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icons/icon-192.png" type="image/png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>Recipe Box</title>
<style>
  body {
    font: 16px/1.5 system-ui, sans-serif;
    margin: 0;
    padding: 0 2rem;
  }
  header {
    margin: 2rem 0 1rem;
  }
  ul {
    list-style: none;
    padding-left: 0;
  }
  li {
    margin: .25rem 0;
  }
  a {
    text-decoration: none;
    color: #0366d6;
  }
  a:hover {
    text-decoration: underline;
  }
  h1 {
    margin: 0 0 1rem;
    font-size: 1.8rem;
  }
  img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 1rem 0;
  }
  .pick {
    margin: 1.5rem 0;
  }
  .hidden {
    display: none;
  }
  .install-banner {
    background: #2c3e50;
    color: white;
    padding: 1rem 2rem;
    margin: 0 -2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }
  .install-banner button {
    background: white;
    color: #2c3e50;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
  .install-banner button:hover {
    opacity: 0.9;
  }
  .debug-info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    font-size: 12px;
    border-radius: 4px;
    max-width: 300px;
    z-index: 1000;
  }
  .sync-panel {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
  }
  .sync-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .sync-status.connected {
    color: #28a745;
  }
  .sync-status.disconnected {
    color: #dc3545;
  }
  .sync-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .sync-buttons button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    background: #007bff;
    color: white;
    cursor: pointer;
    font-size: 14px;
  }
  .sync-buttons button:hover {
    background: #0056b3;
  }
  .sync-buttons button:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }
  .sync-progress {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: #e9ecef;
    border-radius: 4px;
    font-size: 14px;
  }
  .folder-selection {
    margin-top: 1rem;
    padding: 1rem;
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 4px;
  }
  .folder-list {
    max-height: 300px;
    overflow-y: auto;
    margin: 0.5rem 0;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background: white;
  }
  .folder-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    margin: 0.25rem 0;
    cursor: pointer;
  }
  .folder-item:hover {
    background: #f8f9fa;
  }
  .folder-item.selected {
    background: #d1ecf1;
    border-color: #bee5eb;
  }
  .folder-info {
    flex: 1;
  }
  .folder-badges {
    display: flex;
    gap: 0.25rem;
  }
  .folder-badge {
    padding: 0.1rem 0.3rem;
    font-size: 0.7rem;
    border-radius: 2px;
    color: white;
  }
  .folder-badge.shared {
    background: #28a745;
  }
  .folder-badge.owned {
    background: #007bff;
  }
  .share-form {
    margin-top: 1rem;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 4px;
  }
  .share-form input {
    padding: 0.5rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
    margin-right: 0.5rem;
    width: 200px;
  }
</style>
</head>
<body>
<div id="install-banner" class="install-banner hidden">
  <span>Install Recipe Box for easy access</span>
  <button id="install-btn">Install</button>
</div>
<header>
  <div class="sync-panel">
    <div class="sync-status disconnected" id="sync-status">
      <span id="sync-status-text">Not connected to cloud storage</span>
    </div>
    <div class="sync-buttons">
      <button id="sync-connect-btn">Connect to Google Drive</button>
      <button id="sync-now-btn" disabled>Sync Now</button>
      <button id="sync-disconnect-btn" disabled>Disconnect</button>
    </div>
    <div class="sync-progress hidden" id="sync-progress">
      <div id="sync-progress-text">Ready to sync</div>
    </div>
    
    <!-- Folder Selection UI -->
    <div class="folder-selection hidden" id="folder-selection">
      <h3>Select Recipe Folder</h3>
      <p>Choose a folder to store your recipes. You can select an existing shared folder or create a new one.</p>
      
      <div class="sync-buttons">
        <button id="refresh-folders-btn">Refresh Folders</button>
        <button id="create-folder-btn">Create New Folder</button>
        <button id="select-folder-btn" disabled>Use Selected Folder</button>
      </div>
      
      <div class="folder-list" id="folder-list">
        <div>Loading folders...</div>
      </div>
      
      <div class="share-form hidden" id="share-form">
        <h4>Share Selected Folder</h4>
        <p>Share this folder with your partner so you can both access the same recipes.</p>
        <input type="email" id="share-email" placeholder="partner@example.com">
        <button id="share-folder-btn">Share Folder</button>
        <div id="share-result"></div>
      </div>
    </div>
  </div>
  
  <button class="pick" id="pickDir">Open recipe folder (fallback)</button>
  <ul id="index"></ul>
</header>

<article id="viewer"></article>

<div id="debug-info" class="debug-info" style="display: none;"></div>

<script type="module">
  import matter from 'https://cdn.jsdelivr.net/npm/gray-matter@4/+esm';
  import markdownIt from 'https://cdn.jsdelivr.net/npm/markdown-it@14/+esm';
  import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3/+esm';
  import { get, set, clear } from 'https://cdn.jsdelivr.net/npm/idb-keyval@6/+esm';
  
  // Import cloud sync modules
  import './cloud-storage-interface.js';
  import './google-drive-provider.js';
  import { SyncManager } from './sync-manager.js';

  /* Init markdown-it  */
  const md = markdownIt({
    html: true,
    linkify: true,
    typographer: true
  });

  // Global state
  let dirHandle = null;
  const slugToFile = new Map();
  
  // Sync manager
  const syncManager = new SyncManager();
  let syncEnabled = false;
  
  // Expose sync manager for debugging
  window.debugSync = {
    manager: syncManager,
    async listCloudRecipes() {
      if (!syncManager.provider) {
        console.log('Sync not initialized');
        return [];
      }
      const recipes = await syncManager.provider.listRecipes();
      console.log('Cloud recipes found:', recipes);
      return recipes;
    },
    async listLocalRecipes() {
      const recipes = await get('recipeData') || [];
      console.log('Local recipes found:', recipes);
      return recipes;
    },
    async testSync() {
      console.log('Testing sync process...');
      await this.listLocalRecipes();
      await this.listCloudRecipes();
    }
  };

  // UI references
  const pickBtn = document.getElementById('pickDir');
  const indexUl = document.getElementById('index');
  const viewer = document.getElementById('viewer');
  
  // Sync UI references
  const syncStatus = document.getElementById('sync-status');
  const syncStatusText = document.getElementById('sync-status-text');
  const syncConnectBtn = document.getElementById('sync-connect-btn');
  const syncNowBtn = document.getElementById('sync-now-btn');
  const syncDisconnectBtn = document.getElementById('sync-disconnect-btn');
  const syncProgress = document.getElementById('sync-progress');
  const syncProgressText = document.getElementById('sync-progress-text');

  // Helper functions
  const slugify = (s) =>
    s.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');

  const renderIndex = async () => {
    indexUl.innerHTML = '';
    slugToFile.clear();
    
    // First priority: Try to load from synced recipes (IndexedDB)
    const syncedRecipes = await get('recipeData') || [];
    if (syncedRecipes.length > 0) {
      console.log(`Loading ${syncedRecipes.length} synced recipes`);
      for (const recipe of syncedRecipes) {
        const slug = slugify(recipe.name.replace(/\.md$/, ''));
        // Create a File-like object from synced data
        const file = new File([recipe.content], recipe.name, {
          type: 'text/markdown',
          lastModified: recipe.lastModified
        });
        slugToFile.set(slug, file);
        const li = document.createElement('li');
        li.innerHTML = `<a href="#recipe=${slug}">${recipe.name.replace(/\.md$/, '')}</a> <span style="color: #28a745;">‚òÅÔ∏è</span>`;
        indexUl.appendChild(li);
      }
      return; // Exit early if we have synced recipes
    }
    
    // Fallback: Handle local directory/file selection
    if (!dirHandle) {
      const li = document.createElement('li');
      li.innerHTML = '<em>No recipes loaded. Connect to Google Drive above or use the fallback folder picker.</em>';
      indexUl.appendChild(li);
      return;
    }
    
    if (Array.isArray(dirHandle)) {
      // Fallback mode: array of files
      for (const file of dirHandle) {
        if (file.name.endsWith('.md')) {
          const slug = slugify(file.name.replace(/\.md$/, ''));
          slugToFile.set(slug, file);
          const li = document.createElement('li');
          li.innerHTML = `<a href="#recipe=${slug}">${file.name.replace(/\.md$/, '')}</a> <span style="color: #6c757d;">üìÅ</span>`;
          indexUl.appendChild(li);
        }
      }
    } else {
      // Modern mode: directory handle
      for await (const entry of dirHandle.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.md')) {
          const slug = slugify(entry.name.replace(/\.md$/, ''));
          slugToFile.set(slug, entry);
          const li = document.createElement('li');
          li.innerHTML = `<a href="#recipe=${slug}">${entry.name.replace(/\.md$/, '')}</a> <span style="color: #6c757d;">üìÅ</span>`;
          indexUl.appendChild(li);
        }
      }
    }
  };

  const renderRecipe = async (slug) => {
    const entry = slugToFile.get(slug);
    if (!entry) {
      viewer.textContent = 'Recipe not found.';
      return;
    }

    const file = entry.getFile ? await entry.getFile() : entry;  // Works for both FileSystemFileHandle and File
    const text = await file.text();
    const { data: fm, content } = matter(text);

    let html = md.render(content);
    html = DOMPurify.sanitize(html);

    // Inject into DOM
    viewer.innerHTML = `
    <h1>${fm.title ?? file.name.replace(/\\.md$/, '')}</h1>
    ${fm.image ? `<img src="${fm.image}" alt="">` : ''}
    ${Array.isArray(fm.ingredients) ? `
      <h2>What you'll need</h2>
      <ul>${fm.ingredients.map(i => `<li>${DOMPurify.sanitize(i)}</li>`).join('')}</ul>` : ''}
    <h2>What to do</h2>
    ${html}
  `;
  };

  async function verifyPermission(handle, mode = 'read') {
    const opts = { mode };
    // Was permission already granted?
    console.log(await handle.queryPermission(opts))
    if ((await handle.queryPermission(opts)) === 'granted') return true;
    // If not, ask (only once per session)
    return (await handle.requestPermission(opts)) === 'granted';
  }


  // Routing: react to hash
  const route = () => {
    const match = location.hash.match(/recipe=([\w-]+)/);
    if (match && dirHandle) renderRecipe(match[1]);
  };
  window.addEventListener('hashchange', route);

  // Sync functions
  async function updateSyncStatus() {
    const status = await syncManager.getStatus();
    const isAuth = await syncManager.isAuthenticated();
    
    if (isAuth && status.connected) {
      syncStatus.className = 'sync-status connected';
      syncStatusText.textContent = `Connected to ${status.provider}`;
      if (status.lastSync) {
        syncStatusText.textContent += ` - Last sync: ${new Date(status.lastSync).toLocaleString()}`;
      }
      syncConnectBtn.disabled = true;
      syncNowBtn.disabled = status.syncInProgress;
      syncDisconnectBtn.disabled = false;
    } else if (syncManager.provider) {
      syncStatus.className = 'sync-status disconnected';
      syncStatusText.textContent = 'Google Drive available - click to connect';
      syncConnectBtn.disabled = false;
      syncNowBtn.disabled = true;
      syncDisconnectBtn.disabled = true;
    } else {
      syncStatus.className = 'sync-status disconnected';
      syncStatusText.textContent = 'Initializing cloud sync...';
      syncConnectBtn.disabled = true;
      syncNowBtn.disabled = true;
      syncDisconnectBtn.disabled = true;
    }
  }

  async function initializeSync() {
    try {
      // Try to load config and initialize sync
      const { CONFIG } = await import('./config.js');
      const success = await syncManager.initProvider('google-drive', { clientId: CONFIG.google.clientId });
      
      if (success) {
        syncEnabled = true;
        console.log('Sync initialized successfully');
        
        // Check if we're already authenticated (from saved token)
        const isAuth = await syncManager.isAuthenticated();
        console.log('Authentication status after init:', isAuth);
        
        if (isAuth) {
          // We have a valid saved token - update UI to show connected state
          console.log('Found valid saved authentication');
          
          // Try to restore previously selected folder
          const restoredFolder = await syncManager.provider.restoreFolderSelection();
          if (restoredFolder) {
            console.log('Restored folder selection:', restoredFolder);
            
            // Update UI to show connected state
            await updateSyncStatus();
            
            // Automatically sync if we have both auth and folder
            syncStatusText.textContent = 'Connected - Starting automatic sync...';
            
            try {
              // Perform sync
              await performSync();
              console.log('Automatic sync completed successfully');
            } catch (syncError) {
              console.error('Automatic sync failed:', syncError);
              syncStatusText.textContent = `Connected - Sync failed: ${syncError.message}`;
            }
          } else {
            // Authenticated but no folder selected
            console.log('Authenticated but no folder selected');
            await updateSyncStatus();
            syncStatusText.textContent = 'Connected - Please select a recipe folder';
            // Show folder selection UI
            await showFolderSelection();
          }
        } else {
          // Not authenticated - show default disconnected state
          console.log('No valid saved authentication found');
          await updateSyncStatus();
        }
      } else {
        console.log('Sync initialization failed');
      }
    } catch (error) {
      console.log('Sync not available:', error.message);
      // Hide sync panel if config is missing
      document.querySelector('.sync-panel').style.display = 'none';
      return;
    }
  }

  async function connectToSync() {
    syncConnectBtn.disabled = true;
    syncStatusText.textContent = 'Connecting to Google Drive...';
    
    const result = await syncManager.authenticate();
    if (result.success) {
      await updateSyncStatus();
      
      // Check if we have a folder selected
      if (!syncManager.provider.recipeFolderId) {
        syncStatusText.textContent = 'Connected - Please select a recipe folder';
        await showFolderSelection();
      } else {
        // Try to sync immediately after connecting
        await performSync();
      }
    } else {
      syncStatusText.textContent = `Connection failed: ${result.error}`;
      syncConnectBtn.disabled = false;
    }
  }

  async function performSync() {
    if (!await syncManager.isAuthenticated()) {
      await connectToSync();
      return;
    }
    
    // Check if we have a folder selected
    if (!syncManager.provider.recipeFolderId) {
      syncStatusText.textContent = 'Please select a recipe folder first';
      await showFolderSelection();
      return;
    }
    
    console.log('Starting manual sync...');
    syncProgress.classList.remove('hidden');
    syncNowBtn.disabled = true;
    
    // Debug: Check what we can see in the cloud before syncing
    try {
      const cloudRecipes = await syncManager.provider.listRecipes();
      console.log('Cloud recipes before sync:', cloudRecipes);
      const localRecipes = await get('recipeData') || [];
      console.log('Local recipes before sync:', localRecipes);
    } catch (error) {
      console.error('Error listing recipes:', error);
    }
    
    const result = await syncManager.sync((progress) => {
      console.log('Sync progress:', progress);
      syncProgressText.textContent = `${progress.status}: ${progress.progress}%`;
      if (progress.current) {
        syncProgressText.textContent += ` - ${progress.current}`;
      }
    });
    
    console.log('Sync result:', result);
    
    if (result.success) {
      syncProgressText.textContent = `Sync complete! Uploaded: ${result.uploaded}, Downloaded: ${result.downloaded}`;
      // Refresh the recipe list
      await renderIndex();
    } else {
      syncProgressText.textContent = `Sync failed: ${result.error}`;
    }
    
    await updateSyncStatus();
    setTimeout(() => syncProgress.classList.add('hidden'), 3000);
  }

  async function disconnectFromSync() {
    await syncManager.signOut();
    await updateSyncStatus();
  }

  async function pickRecipeFolder() {
    if ('showDirectoryPicker' in window) {
      // Modern Chromium path (read + write)
      return await window.showDirectoryPicker();
    }

    // Fallback: let user pick a whole folder read-only (WebKit proprietary)
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'file';
      input.webkitdirectory = true;
      input.multiple = true;
      input.addEventListener('change', () => {
        resolve(Array.from(input.files));
      });
      input.click();
    });
  }

  // Auto-restore directory permission on reload
  pickBtn.addEventListener('click', async () => {
    dirHandle = await pickRecipeFolder();
    if (dirHandle) {
      // Save both directory handles and file arrays
      if (dirHandle.kind === 'directory') {
        // Modern browsers: save directory handle
        await set('recipeDirHandle', dirHandle);
      } else if (Array.isArray(dirHandle)) {
        // Fallback browsers: Store recipe content in IndexedDB for persistence
        console.log('Storing recipe files in IndexedDB for persistence...');
        const recipes = [];
        for (const file of dirHandle) {
          if (file.name.endsWith('.md')) {
            const content = await file.text();
            recipes.push({
              name: file.name,
              content: content,
              lastModified: file.lastModified,
              size: file.size
            });
          }
        }
        await set('recipeData', recipes);
        console.log(`Stored ${recipes.length} recipes in IndexedDB`);
      }
      await renderIndex();
      indexUl.classList.remove('hidden');
      route();
    }
  });
  
  // Folder selection UI references
  const folderSelection = document.getElementById('folder-selection');
  const folderList = document.getElementById('folder-list');
  const refreshFoldersBtn = document.getElementById('refresh-folders-btn');
  const createFolderBtn = document.getElementById('create-folder-btn');
  const selectFolderBtn = document.getElementById('select-folder-btn');
  const shareForm = document.getElementById('share-form');
  const shareEmailInput = document.getElementById('share-email');
  const shareFolderBtn = document.getElementById('share-folder-btn');
  const shareResult = document.getElementById('share-result');

  let selectedFolderId = null;

  // Folder selection functions
  async function showFolderSelection() {
    folderSelection.classList.remove('hidden');
    await loadAvailableFolders();
  }

  async function hideFolderSelection() {
    folderSelection.classList.add('hidden');
    shareForm.classList.add('hidden');
  }

  async function loadAvailableFolders() {
    folderList.innerHTML = '<div>Loading folders...</div>';
    
    try {
      const folders = await syncManager.provider.listAvailableFolders();
      folderList.innerHTML = '';
      
      if (folders.length === 0) {
        folderList.innerHTML = '<div><em>No folders found. Create a new one below.</em></div>';
        return;
      }
      
      console.log('Folder selection debug:', {
        totalFolders: folders.length,
        folders: folders.map(f => ({
          name: f.name,
          id: f.id,
          isPrevious: f.isPrevious,
          isRecipeBox: f.isRecipeBox
        }))
      });
      
      // Determine which folder to auto-select
      let folderToAutoSelect = null;
      
      // Priority 1: Previously selected folder
      const previousFolder = folders.find(f => f.isPrevious);
      if (previousFolder) {
        folderToAutoSelect = previousFolder;
      }
      // Priority 2: RecipeBox folder (if no previous selection)
      else {
        const recipeBoxFolder = folders.find(f => f.isRecipeBox);
        if (recipeBoxFolder) {
          folderToAutoSelect = recipeBoxFolder;
        }
      }
      
      // Sort folders: Previous first, then RecipeBox, then alphabetically
      const sortedFolders = [...folders].sort((a, b) => {
        if (a.isPrevious) return -1;
        if (b.isPrevious) return 1;
        if (a.isRecipeBox) return -1;
        if (b.isRecipeBox) return 1;
        return a.name.localeCompare(b.name);
      });
      
      for (const folder of sortedFolders) {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'folder-item';
        folderDiv.dataset.folderId = folder.id;
        
        // Auto-select the determined folder
        const shouldAutoSelect = folderToAutoSelect && folder.id === folderToAutoSelect.id;
        if (shouldAutoSelect) {
          folderDiv.classList.add('selected');
          selectedFolderId = folder.id;
          selectFolderBtn.disabled = false;
          shareForm.classList.remove('hidden');
        }
        
        // Determine the label and badges
        let label = folder.name;
        let badges = [];
        
        // Ownership/sharing badges
        if (folder.isOwned) {
          badges.push('<span class="folder-badge owned">Owned</span>');
        }
        if (folder.isShared) {
          badges.push('<span class="folder-badge shared">Shared</span>');
        }
        
        // Special status badges
        if (folder.isPrevious && folder.isRecipeBox) {
          label += ' (Current)';
          badges.push('<span class="folder-badge" style="background: #17a2b8;">Current</span>');
        } else if (folder.isPrevious) {
          label += ' (Previously Selected)';
          badges.push('<span class="folder-badge" style="background: #17a2b8;">Previous</span>');
        } else if (folder.isRecipeBox) {
          label += ' (Recommended)';
          badges.push('<span class="folder-badge" style="background: #28a745;">Recommended</span>');
        }
        
        folderDiv.innerHTML = `
          <div class="folder-info">
            <strong>${label}</strong>
            <div class="folder-badges">
              ${badges.filter(badge => badge).join('')}
            </div>
          </div>
        `;
        
        folderDiv.addEventListener('click', () => selectFolder(folder.id, folderDiv));
        folderList.appendChild(folderDiv);
      }
      
      // If we auto-selected a folder, log it
      if (folderToAutoSelect) {
        console.log('Auto-selected folder:', folderToAutoSelect.name, folderToAutoSelect.id);
      }
    } catch (error) {
      folderList.innerHTML = `<div style="color: red;">Error loading folders: ${error.message}</div>`;
    }
  }

  function selectFolder(folderId, folderElement) {
    // Clear previous selection
    document.querySelectorAll('.folder-item').forEach(item => {
      item.classList.remove('selected');
    });
    
    // Select new folder
    folderElement.classList.add('selected');
    selectedFolderId = folderId;
    
    // Enable the select button
    selectFolderBtn.disabled = false;
    
    // Show share form
    shareForm.classList.remove('hidden');
  }

  async function createNewFolder() {
    const folderName = prompt('Enter folder name:', 'RecipeBox');
    if (!folderName) return;
    
    try {
      createFolderBtn.disabled = true;
      createFolderBtn.textContent = 'Creating...';
      
      const folderId = await syncManager.provider.createRecipeFolder(folderName);
      
      // Refresh folder list and select the new folder
      await loadAvailableFolders();
      
      // Find and select the newly created folder
      const folderElements = document.querySelectorAll('.folder-item');
      for (const element of folderElements) {
        if (element.dataset.folderId === folderId) {
          selectFolder(folderId, element);
          break;
        }
      }
      
      alert(`Folder "${folderName}" created successfully!`);
    } catch (error) {
      alert(`Failed to create folder: ${error.message}`);
    } finally {
      createFolderBtn.disabled = false;
      createFolderBtn.textContent = 'Create New Folder';
    }
  }

  async function shareSelectedFolder() {
    if (!selectedFolderId) {
      alert('Please select a folder first');
      return;
    }
    
    const email = shareEmailInput.value.trim();
    if (!email) {
      alert('Please enter an email address');
      return;
    }
    
    try {
      shareFolderBtn.disabled = true;
      shareFolderBtn.textContent = 'Sharing...';
      shareResult.innerHTML = '';
      
      const result = await syncManager.provider.shareFolder(selectedFolderId, email);
      
      if (result.success) {
        shareResult.innerHTML = '<div style="color: green;">‚úì Folder shared successfully!</div>';
        shareEmailInput.value = '';
      } else {
        shareResult.innerHTML = `<div style="color: red;">‚úó Failed to share: ${result.error}</div>`;
      }
    } catch (error) {
      shareResult.innerHTML = `<div style="color: red;">‚úó Error: ${error.message}</div>`;
    } finally {
      shareFolderBtn.disabled = false;
      shareFolderBtn.textContent = 'Share Folder';
    }
  }

  async function finalizeFolderSelection() {
    if (!selectedFolderId) {
      alert('Please select a folder first');
      return;
    }
    
    try {
      await syncManager.provider.selectFolder(selectedFolderId);
      await hideFolderSelection();
      await updateSyncStatus();
      
      // Try to sync after folder selection
      await performSync();
    } catch (error) {
      alert(`Error selecting folder: ${error.message}`);
    }
  }

  // Folder selection event handlers
  refreshFoldersBtn.addEventListener('click', loadAvailableFolders);
  createFolderBtn.addEventListener('click', createNewFolder);
  selectFolderBtn.addEventListener('click', finalizeFolderSelection);
  shareFolderBtn.addEventListener('click', shareSelectedFolder);

  // Sync event handlers
  syncConnectBtn.addEventListener('click', connectToSync);
  syncNowBtn.addEventListener('click', performSync);
  syncDisconnectBtn.addEventListener('click', disconnectFromSync);
  
  (async () => {
    try {
      // Try to restore directory handle first (modern browsers)
      const saved = await get('recipeDirHandle');
      if (saved && await verifyPermission(saved, 'read')) {
        dirHandle = saved;
        await renderIndex();
        indexUl.classList.remove('hidden');
        route();
        return;
      }
    } catch (err) {
      console.log('Error restoring directory handle:', err);
    }
    
    try {
      // Fallback: try to restore recipe data (Android/fallback browsers)
      const recipeData = await get('recipeData');
      if (recipeData && recipeData.length > 0) {
        console.log(`Restored ${recipeData.length} recipes from IndexedDB`);
        // Create mock File objects from stored data
        dirHandle = recipeData.map(recipe => new File([recipe.content], recipe.name, {
          type: 'text/markdown',
          lastModified: recipe.lastModified
        }));
        await renderIndex();
        indexUl.classList.remove('hidden');
        route();
      }
    } catch (err) {
      console.log('Error restoring recipe data:', err);
    }
  })();

  // Initialize sync functionality
  (async () => {
    try {
      console.log('Starting sync initialization...');
      await initializeSync();
      console.log('Sync initialization complete');
      // After sync is initialized, try to load synced recipes
      await renderIndex();
      indexUl.classList.remove('hidden');
      route();
      console.log('DebugSync should now be available');
    } catch (error) {
      console.error('Error during sync initialization:', error);
    }
  })();

  // PWA Service Worker Registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const registration = await navigator.serviceWorker.register('/forked/sw.js');
        console.log('ServiceWorker registration successful:', registration.scope);
        
        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker available
              console.log('New content available; refresh to update.');
            }
          });
        });
      } catch (err) {
        console.log('ServiceWorker registration failed:', err);
      }
    });
  }

  // PWA Install prompt
  let deferredPrompt;
  const installBanner = document.getElementById('install-banner');
  const installBtn = document.getElementById('install-btn');
  
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    // Only show banner if not already running as installed PWA
    if (!isRunningStandalone()) {
      installBanner.classList.remove('hidden');
    }
  });
  
  // Check if app is running in standalone mode (installed PWA)
  function isRunningStandalone() {
    const standalone = window.matchMedia('(display-mode: standalone)').matches ||
                      window.navigator.standalone === true ||
                      document.referrer.includes('android-app://') ||
                      window.matchMedia('(display-mode: fullscreen)').matches ||
                      window.matchMedia('(display-mode: minimal-ui)').matches;
    
    console.log('PWA Standalone Detection:', {
      'display-mode: standalone': window.matchMedia('(display-mode: standalone)').matches,
      'navigator.standalone': window.navigator.standalone,
      'referrer': document.referrer,
      'display-mode: fullscreen': window.matchMedia('(display-mode: fullscreen)').matches,
      'display-mode: minimal-ui': window.matchMedia('(display-mode: minimal-ui)').matches,
      'final result': standalone
    });
    
    return standalone;
  }
  
  // Hide banner if already running as PWA
  async function checkAndHideBanner() {
    // Check if previously installed
    const wasInstalled = await get('appInstalled');
    const isStandalone = isRunningStandalone();
    
    // Show debug info on screen
    const debugDiv = document.getElementById('debug-info');
    if (debugDiv) {
      debugDiv.innerHTML = `
        <strong>PWA Debug Info:</strong><br>
        Current URL: ${window.location.href}<br>
        Standalone: ${isStandalone}<br>
        Was Installed: ${wasInstalled}<br>
        Display Mode: ${window.matchMedia('(display-mode: standalone)').matches ? 'standalone' : 'browser'}<br>
        Navigator Standalone: ${window.navigator.standalone}<br>
        Referrer: ${document.referrer}<br>
        User Agent: ${navigator.userAgent.substring(0, 50)}...<br>
        <button onclick="clearCacheAndReload()" style="margin-top:5px;padding:2px 5px;">Clear Cache & Reload</button>
      `;
      debugDiv.style.display = 'block';
      
      // Hide debug after 10 seconds
      setTimeout(() => debugDiv.style.display = 'none', 10000);
    } else {
      console.error('Debug div not found!');
    }
    
    if (isStandalone || wasInstalled) {
      console.log('Running as PWA or previously installed - hiding install banner');
      if (installBanner) {
        installBanner.classList.add('hidden');
        installBanner.style.display = 'none'; // Force hide with CSS
        if (debugDiv) debugDiv.innerHTML += `<br><strong>Banner Hidden:</strong> YES`;
      } else {
        if (debugDiv) debugDiv.innerHTML += `<br><strong>ERROR:</strong> Banner element not found!`;
      }
    } else {
      console.log('Running in browser - install banner may be shown');
      if (debugDiv) debugDiv.innerHTML += `<br><strong>Banner:</strong> Should be visible`;
    }
  }
  
  // Only check after DOM is loaded to ensure elements exist
  document.addEventListener('DOMContentLoaded', checkAndHideBanner);
  
  // Also check when page is fully loaded
  window.addEventListener('load', checkAndHideBanner);
  
  installBtn.addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);
    deferredPrompt = null;
    installBanner.classList.add('hidden');
  });
  
  // Hide banner if already installed
  window.addEventListener('appinstalled', async () => {
    console.log('Recipe Box app installed');
    installBanner.classList.add('hidden');
    // Remember that the app was installed
    await set('appInstalled', true);
  });

  // Function to clear cache and reload (for debugging)
  window.clearCacheAndReload = async () => {
    try {
      // Clear service worker caches
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
      
      // Clear IndexedDB data
      await clear();
      
      // Unregister service worker
      if ('serviceWorker' in navigator) {
        const registrations = await navigator.serviceWorker.getRegistrations();
        await Promise.all(registrations.map(reg => reg.unregister()));
      }
      
      // Force reload
      window.location.reload(true);
    } catch (err) {
      console.error('Error clearing cache:', err);
      window.location.reload(true);
    }
  };
</script>
</body>
</html>
